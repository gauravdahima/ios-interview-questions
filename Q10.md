
Q9: How access control applies to initializers?

An initializer's access control dictates who can create an instance of that type (class, struct, or enum).

The rules are logical, but they have some crucial nuances, especially regarding default initializers.

## 1. The Core Rule: An Initializer Can't Be More Public Than Its Type

This is the most fundamental rule. An initializer's access level is capped by the access level of its type.

You cannot have a public init inside an internal class.

You cannot have an internal init inside a private struct.

It's logical: Why would you let everyone (public) create an instance of something that only some of your code (internal) is allowed to see?

```swift
// This is NOT allowed and will not compile
internal class MyManager {
    // error: initializer cannot be more permissive
    //        than its type
    public init() { ... } 
}
```

## 2. Explicit Initializers (What You Write)

This is the most straightforward case. You simply add the access modifier before the init keyword.

public init

Who can use it? Anyone, inside or outside the module.

When? This is for your framework's public API. You are explicitly allowing consumers of your framework to create instances of this class.

```swift
public class MyButton {
    // Anyone importing this module can create a MyButton
    public init(title: String) { ... }
}
```

internal init

Who can use it? Only code from within your module.

When? This is the default. You might also use it explicitly in a public class to prevent consumers of your framework from creating it directly.

```swift
public class FrameworkManager {
    // We make this init 'internal' on purpose.
    // We don't want people outside our module making one.
    internal init(config: Config) { ... }
    
    // They must use our 'shared' instance instead.
    public static let shared = FrameworkManager(config: .default)
}
```

private init

Who can use it? Only code from within the same class/struct (and same-file extensions).

When? This is the key to creating Singletons. You make the initializer private so that no one else can create an instance.

```swift
public class Logger {
    // 1. The only instance
    public static let shared = Logger()
    
    // 2. The init is private, so no one else can call Logger()
    private init() { ... }
    
    public func log(_ message: String) { ... }
}

// This is the only way to use it:
Logger.shared.log("Hello")

// This will NOT compile:
// let myLogger = Logger() // error: 'Logger' initializer is inaccessible
```


## 3. Default Initializers (The "Gotchas")

This is the part that often trips people up. If you don't write an init yourself, Swift might provide one. Its access level is not always what you expect.

üì¶ public struct

The Gotcha: A public struct gets a default memberwise initializer that is only internal, not public.

Why? Swift wants you to be intentional about your public API. It won't expose an initializer unless you explicitly write it.

The Fix: If you want consumers of your framework to be able to create your public struct, you must write an explicit public init yourself.

```swift
// IN A FRAMEWORK:

// Even though the struct is public...
public struct User {
    public var name: String
    public var id: Int
    
    // ...if you don't write this, the default init
    // is 'internal'. People outside can't use it!
    public init(name: String, id: Int) {
        self.name = name
        self.id = id
    }
}
```

üè¢ public class

The Gotcha: A public class (with no un-initialized properties) gets a default no-argument initializer (init()) that is also internal, not public.

The Fix: Same as structs. If you want people to be able to create your class, you must provide an explicit public init() {}.


## 4. Required Initializers

Access control for required init works similarly, but the rules are enforced on subclasses.

A required init must have the same or more restrictive access level as its class.

You must provide the access modifier on every subclass implementation of the required init.

```swift
public class BaseView {
    public required init(frame: CGRect) { ... }
}

public class MyCustomView: BaseView {
    // This 'required' init must also be 'public'
    // to match the superclass's requirement.
    public required init(frame: CGRect) {
        super.init(frame: frame)
        // ...
    }
}
```
