
Q9: What are the different types of initializers?

An initializer is a special method (init) whose sole job is to prepare a new instance of a class, struct, or enum for use. It ensures all stored properties on that instance have a valid initial value before the instance is used.

##1. Designated vs. Convenience Initializers (Classes Only)

This is the most fundamental concept for class initialization.

Designated Initializers (init)

Role: The primary initializer for a class.

Job: Must fully initialize all properties introduced by its own class.

Rule: Must call a designated initializer from its immediate superclass (unless it's a base class).

Summary: A class must have at least one designated initializer. It's the "main" one that does all the essential work.

```swift
class Vehicle {
    var numberOfWheels: Int
    
    // This is a DESIGNATED initializer
    init(numberOfWheels: Int) {
        self.numberOfWheels = numberOfWheels
    }
}
```

Convenience Initializers (convenience init)

Role: A secondary, "helper" or "shortcut" initializer.

Job: Provides default values or a simpler setup.

Rule: Must call another initializer from the same class (it can be a designated init or another convenience init).

Summary: It's for "convenience." It must ultimately "delegate" its work to a designated initializer within the same class.

```swift
class Bicycle: Vehicle {
    var color: String = "Blue"
    
    // This is a DESIGNATED initializer
    init() {
        // Must call a designated init from its superclass
        super.init(numberOfWheels: 2)
    }
    
    // This is a CONVENIENCE initializer
    convenience init(color: String) {
        // Must call an init from THIS class (Bicycle)
        self.init() 
        self.color = color // Can only modify properties *after* self.init()
    }
}
```

❓ Key Interview Question: Two-Phase Initialization

"Why do these rules exist? What is Two-Phase Initialization?"

These rules exist to guarantee safety. Swift ensures every single stored property has a value before you can use it. This happens in two phases:

Phase 1 (Bottom-Up):

A designated or convenience init is called.

Memory is allocated for the new instance (but not yet initialized).

A designated init ensures all properties from its own class are set.

The designated init calls its superclass's designated init.

This continues all the way up the chain to the base class.

Once the base class is finished, the instance is considered "fully initialized" from a memory perspective.


Phase 2 (Top-Down):

The chain of initializers unwinds, starting from the base class.

Now that the instance is "complete," each designated init on the way down can access self, modify properties (including inherited ones), and call instance methods.

Finally, any convenience initializers run and are free to modify the instance.

This process prevents you from accessing a property that hasn't been set yet.


##2. Failable Initializers (init? and init!)

Role: To handle initialization that might fail and return nil.

Why? Sometimes, you can't guarantee an instance can be created.

Converting a String to an Int (Int("hello") returns nil).

Loading an image from a filename that doesn't exist (UIImage(named: "missing.png")).

Passing invalid parameters.

How: You use return nil at any point in the init? to trigger the failure.

```swift
struct Temperature {
    var celsius: Double
    
    // This init can fail
    init?(celsius: Double) {
        if celsius < -273.15 {
            // This is "absolute zero," so it's an invalid temp
            return nil 
        }
        self.celsius = celsius
    }
}

let validTemp = Temperature(celsius: 20)  // This is a Temperature?
let invalidTemp = Temperature(celsius: -300) // This is nil
```

init! is a failable, implicitly unwrapped optional initializer. It's less common and implies that if it does fail, you're okay with a runtime crash.

❓ Key Interview Question: Overriding Failable Inits

"Can I override a failable initializer (init?) with a non-failable one (init)?"

Yes, you can. This is called "upgrading" the initializer. You are guaranteeing that your subclass's implementation cannot fail.

You can override init? with init.

You can override init? with init?.

You cannot override init (non-failable) with init? (failable). You can't make a previously-guaranteed init suddenly able to fail.


##3. Required Initializers (required init)

Role: To force all subclasses to provide an implementation of this specific initializer.

Keyword: You add the required keyword before init.

Rule: If a subclass adds any of its own initializers, it must also implement the required initializer (and mark it as required too).

```swift
protocol Animal {
    init(name: String) // Protocols often require inits
}

class Dog: Animal {
    var name: String
    
    // 1. Class must be 'final' OR...
    // 2. This init must be 'required' to satisfy the protocol.
    required init(name: String) {
        self.name = name
    }
}

class Puppy: Dog {
    var toy: String
    
    init(name: String, toy: String) {
        self.toy = toy
        super.init(name: name)
    }
    
    // Because Dog's init was 'required', Puppy *must* provide it too.
    required init(name: String) {
        self.toy = "Ball"
        super.init(name: name)
    }
}
```

This is most common when conforming to protocols (like NSCoding) that define an initializer.

##4. Default and Memberwise Initializers (The "Free" Ones)

Swift can provide two types of initializers automatically, but only if you do not write any custom inits yourself.

Default Initializer (init())

What it is: A simple, no-argument initializer.

When you get it: For any class or struct where you provide default values for all stored properties.

```swift
struct Book {
    var title: String = "Untitled"
    var pages: Int = 0
}

let myBook = Book() // Works! We get init() for free.
```

Memberwise Initializer (Structs Only)

What it is: An initializer with arguments for all stored properties.

When you get it: For any struct (even if it has default values).

```swift
struct Point {
    var x: Double
    var y: Double
}

let origin = Point(x: 0, y: 0) // Works! We get init(x:y:) for free.
```

❓ Key Interview Question: The "Disappearing Init"

"I have a struct with default values, so MyStruct() works. But as soon as I add my own init(custom:), the MyStruct() call breaks. Why?"

Answer: The moment you declare any custom initializer, Swift disables both the default init() and the memberwise init. It assumes you now want full, manual control over initialization.

The Fix: If you want to keep the "free" initializers and add your own, declare your custom init inside an extension:

```swift
struct Size {
    var width = 0.0
    var height = 0.0
}

extension Size {
    // By putting this in an extension...
    init(square: Double) {
        self.width = square
        self.height = square
    }
}

let s1 = Size() // ...this still works!
let s2 = Size(width: 10, height: 5) // ...this still works!
let s3 = Size(square: 10) // ...and this new one works, too.
```


