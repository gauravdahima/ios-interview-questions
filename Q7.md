
Q7: What is capture list?

A capture list is a list of variables from the surrounding context, placed in square brackets [ ] at the beginning of a closure's body.

Its primary purpose is to change how the closure captures those variables, most often to break strong reference cycles (memory leaks).

The Problem: Strong Reference Cycles

By default, when a closure uses a variable from its context (like self), it creates a strong reference to it.

As we just discussed with @escaping closures, if a class holds a strong reference to an escaping closure, and that closure also holds a strong reference to self (the class), you get a cycle. Neither can be deallocated.

The Solution: [weak self]

The capture list is how you fix this. You explicitly tell the closure how to capture self.

```swift
myObject.doSomethingAsync { [weak self] result in
    // ... closure body ...
}
```

By adding [weak self], you are telling the closure: "Do not take a strong reference to self. Instead, just hold a weak reference."

This breaks the cycle. The class holds a strong reference to the closure, but the closure only holds a weak reference back to the class. Now, the class can be deallocated normally.

How to Use a Capture List

Once you use [weak self], the rules of weak references apply:

self becomes an optional inside the closure (i.e., self is now of type MyClass?).

The system will automatically set it to nil if the object it was referencing gets deallocated.

This leads to the most common pattern in all of Swift development:

```swift
class MyViewController: UIViewController {
    let networkService = NetworkService()
    
    func fetchData() {
        networkService.loadData { [weak self] data in
            // 'self' is now an optional (MyViewController?)
            
            // We must safely unwrap it.
            // This is the "safe shadowing" pattern.
            guard let self = self else {
                // 'self' was deallocated (e.g., the user
                // navigated away). There's nothing to do.
                return
            }
            
            // Inside this guard, 'self' is a new, non-optional,
            // strong reference that lasts only for this scope.
            // This is 100% safe.
            self.updateUI(with: data)
        }
    }
    
    func updateUI(with data: Data) { /* ... */ }
}
```

Other Details (Senior-Level Knowledge)

[unowned self]: You can also use unowned. This captures self as unowned instead of weak.

Pro: self is not an optional, so you don't need the guard let.

Con (Major Risk): If the closure is called after self has been deallocated, your app will crash.

My Rule: Always default to [weak self]. The safety is worth the one extra line of code.


Capturing Value Types: You can also use capture lists to create a copy of a value type (like a struct or Int) at the moment the closure is defined.

```swift
var count = 10

// The [count] capture list creates a copy of 'count' (value 10)
let myClosure = { [count] in
    // This 'count' is the copy, not the original.
    print(count)
}

count = 20 // This changes the original 'count'

myClosure() // This will print 10
```

This is less common but useful for "freezing" the state of a value at a specific point in time.

In summary: A capture list is your manual control over how a closure holds onto external variables, with [weak self] being the essential tool you'll use every day to prevent memory leaks.
