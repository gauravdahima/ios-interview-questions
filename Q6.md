
Q6: What are closures? What are trailing closures? What are escaping and non-escaping closures?

1. What Are Closures?

At its simplest, a closure is a self-contained block of functionality that can be passed around and used in your code.

Think of it as a function with no name (an "anonymous function") that you can store in a variable, pass as an argument to another function, or return from a function.

The special "superpower" of a closure is that it captures (or "closes over") any constants and variables from the context in which it's defined. This means it can access and modify variables from the function it was created in, even after that function has finished running.

Syntax: The full syntax for a closure expression is:

```swift
{ (parameters) -> ReturnType in
    // statements
}
```

```swift
Practical Example: Let's say you want to sort an array of names by length. The sorted(by:) method takes a closure as its argument.

let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

// 1. Using a full, explicit closure:
let sortedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1.count < s2.count
})

// 2. Swift can infer types and the return, so it gets simpler:
let sortedNames = names.sorted(by: { s1, s2 in s1.count < s2.count })

// 3. Swift also provides shorthand argument names:
let sortedNames = names.sorted(by: { $0.count < $1.count })

// 4. And if it's just a simple operator, you can do this:
let sortedNames = names.sorted(by: <)
```

All of these achieve the same thing, but they use progressively more concise closure syntax.

2. What Are Trailing Closures?

A trailing closure is just syntactic sugar to make your code cleaner.

The rule is: If the last argument to a function is a closure, you can write that closure outside of the function's parentheses.

This makes your code look less like a nested argument and more like a special language feature (like if or for).

Classic Example: UIView.animate

Without trailing closure syntax (the "ugly" way):

```swift
UIView.animate(withDuration: 0.3, animations: {
    // This is the closure, passed *inside* the parentheses
    self.myView.alpha = 0
})
```

With trailing closure syntax (the "clean" way):

```swift
UIView.animate(withDuration: 0.3) {
    // The closure is written *after* the parentheses
    self.myView.alpha = 0
}
```

They are functionally identical. The second one is just much easier to read.

Note: As of Swift 5.3, you can use multiple trailing closures, but the most common case is for a single, final closure.


3. Escaping vs. Non-Escaping Closures

This is the most critical part for an interview, as it deals with memory management and object lifetimes. This distinction tells the compiler what the lifetime of the closure will be.

Non-Escaping Closures (The Default)

Definition: A non-escaping closure is one that is executed before the function it was passed into returns.

Analogy: You give a co-worker a simple task. They do it immediately while you wait, and then you both move on. The task is finished.

Compiler Optimization: Since the compiler knows the closure's life is short, it can make optimizations. It doesn't have to worry about retain cycles.

This is the default in Swift. You don't have to write anything.

Example: The sorted(by:) method. That closure is used only during the sorting operation and is then discarded.

```swift
func doWork(task: () -> Void) {
    // 1. task is executed
    task()
    // 2. The function returns
}
// 'task' is non-escaping
```

Escaping Closures (@escaping)

Definition: An escaping closure is one that is stored away (e.g., in a property or an array) to be executed later, after the function it was passed into has already returned.

Analogy: You give a co-worker a task and your "callback number." They say "Got it, I'll call you back when it's done." You hang up and do other things. The task "escapes" the initial conversation.

Keyword: You must mark the closure with the @escaping keyword in the function's parameters.

Classic Use Case: Asynchronous operations, like a network request.

Example: A network call's completion handler.

```swift
class NetworkManager {
    // The 'completion' closure MUST be @escaping because
    // it will only be called *after* the network request finishes,
    // which is long after fetchData() has returned.
    func fetchData(completion: @escaping (String) -> Void) {
        
        print("1. fetchData function is starting...")

        // Simulate an async network call
        DispatchQueue.global().asyncAfter(deadline: .now() + 2) {
            // 3. This code runs 2 seconds later!
            let data = "Mock Data"
            completion(data) // The escaping closure is called here
        }

        print("2. fetchData function is returning.")
    }
}
```


4. Interview-Critical Details (The "Gotchas")

This is what separates a senior-level answer.

The #1 Pitfall: Retain Cycles with @escaping

This is the most important concept.

An @escaping closure is often stored as a property on a class (e.g., self.onComplete = completion).

If that closure also captures a strong reference to self (the class instance), you create a strong reference cycle (retain cycle).

The Cycle: The class holds a strong reference to the closure, and the closure holds a strong reference to the class (self)

The Result: Neither can ever be deallocated. This is a memory leak.

The Solution: You must use a capture list to break the cycle, exactly as we discussed with weak vs. unowned.

Bad Code (Memory Leak):

```swift
class MyViewController: UIViewController {
    let networkManager = NetworkManager()
    
    func loadData() {
        networkManager.fetchData { data in
            // This closure strongly captures 'self'
            // If networkManager holds this closure, we have a cycle.
            self.updateUI(with: data) 
        }
    }
    
    func updateUI(with data: Data) { /* ... */ }
}
```

Good Code (Fixing the Leak):

```swift
class MyViewController: UIViewController {
    // ...
    func loadData() {
        networkManager.fetchData { [weak self] data in
            // 1. Use [weak self] to make the capture weak
            // 2. Use 'guard let' to get a temporary strong ref
            guard let self = self else { return }
            
            // 3. Now it's safe to use 'self'
            self.updateUI(with: data)
        }
    }
    // ...
}
```

Summary for an Interview:

Closure: An anonymous function you can pass around. It captures its context.

Trailing Closure: Syntactic sugar for readability when a closure is the last argument.

Non-Escaping: Default. Executed before the function returns. Safe.

Escaping: Marked with @escaping. Executed after the function returns (e.g., network callbacks).

The Gotcha: Escaping closures can cause retain cycles. You must manage this with a capture list, typically [weak self].


