
Q3: What are lazy properties in swift ?

A lazy property is a property whose initial value is not calculated until the very first time it is accessed.

It's a powerful tool for performance optimization. You declare it by prefixing a var with the lazy keyword.

How It Works

Normally, all stored properties of a class are initialized as part of the init process. A lazy property, however, defers this.

Its value is typically provided by a closure, which is executed only once—the first time you try to read the property. After that, the result of the closure is "cached," and that stored value is returned for all future accesses.

Syntax:

```swift
class DataManager {
    // This property is NOT initialized when DataManager is created
    lazy var complexData: [String] = {
        // Imagine this is a very expensive operation:
        // - Reading a large file from disk
        // - Parsing a complex JSON blob
        // - Performing a difficult calculation
        print("Lazy property is being initialized...")
        return (1...1000).map { "Item \($0)" }
    }()
}

let manager = DataManager()
print("DataManager created.")

// At this point, "Lazy property is being initialized..." has NOT been printed.
// The complexData array does not exist in memory yet.

print("About to access complexData...")
let data = manager.complexData // <-- Initialization happens NOW
print("Access complete.")

// Accessing it again does NOT re-run the closure
let data2 = manager.complexData
print("Second access complete.")
```

Expected Output:

DataManager created.
About to access complexData...
Lazy property is being initialized...
Access complete.
Second access complete.

Key Use Cases for Lazy Properties

1. Deferring Expensive Initialization

This is the main use case. If a property is computationally expensive to create (like a UIImage from disk, a database connection, or a complex algorithm's result) and it might not even be needed, you make it lazy.

Why? It improves the app's startup time and responsiveness. If the DataManager in the example above was part of my initial view controller, initializing it would be much faster because it's not "paying the cost" of creating complexData until (and if) the user actually taps a button that requires it.

2. When a Property's Value Depends on self

A standard property initializer runs during init, at which point self is not yet fully initialized. You can't call other instance methods or properties.

A lazy property's closure, however, runs after init is complete. This means it can safely access self and its other properties.

```swift
class User {
    var firstName: String
    var lastName: String

    // This property formats other properties of the same instance.
    lazy var fullName: String = {
        // We can safely access 'self' here.
        return "\(self.firstName) \(self.lastName)"
    }()

    init(firstName: String, lastName: String) {
        self.firstName = firstName
        self.lastName = lastName
    }
}
```

Important Considerations and Pitfalls (The Senior-Level Nuance)

There are three critical "gotchas" with lazy properties that every senior developer must know.

1. ⚠️ Thread Safety (The Most Important Pitfall)

Lazy properties are NOT inherently thread-safe.

If multiple threads try to access a lazy property for the first time at the exact same time, there is a race condition. It's possible for the initialization closure to be run more than once. The last one to finish "wins" and sets the value, but you've still wasted computation and could have unpredictable side effects.

My Solution: If a lazy property must be accessed from multiple threads (e.g., a shared DataManager singleton), I must manually add synchronization. I would typically wrap the initialization in a DispatchQueue.sync block or use an NSLock to ensure only one thread can initialize it.

2. It Must Be a var

A lazy property must be a variable (var), never a constant (let).

Why? Its value is mutated. From the compiler's perspective, the object's state changes when the lazy property is first accessed (it transitions from "nil/uninitialized" to "has a value"). This is a mutation, so it cannot be a let.

3. Use on structs (Value Types)

You can use lazy properties on structs, but it has a key implication:

Because accessing a lazy property mutates the instance (as explained above), any method on the struct that accesses the lazy property must be marked as mutating.

```swift
struct SizeCalculator {
    var width: Double
    var height: Double

    lazy var area: Double = {
        return self.width * self.height
    }()
    
    // This function must be 'mutating' because it *might*
    // trigger the initialization of 'area'.
    mutating func getArea() -> Double {
        return self.area // This line makes the method mutating
    }
}
```

This can be surprising and can have ripple effects, as it means you can't call getArea() on an immutable let instance of SizeCalculator.

In summary, lazy is a fantastic tool for optimizing performance by deferring expensive work, but it must be used with care, especially regarding thread safety.
